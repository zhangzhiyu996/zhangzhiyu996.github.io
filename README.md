# zhangzhiyu996.github.io

##### 2月10日

### 2020年大寒假程序训练笔记

##### 第一章 状压DP

###### 一、总述

**状压DP**是利用**计算机二进制**的性质来描述状态的一种DP方式，经常与BFS和DP联用，棋盘问题尤其多见

###### 二、常见位运算

1.判断一个数字x二进制下第i位是不是等于1。

方法：*if*(((1<<(*i*−1))&*x*)>0)

2.将一个数字x二进制下第i位更改成1。

方法：*x*=*x*\|(1<<(*i*−1))

3.把一个数字二进制下**最靠右的第一个1去掉**。

方法：*x*=*x*&(*x*−1)

4.最低位1的位置，树状数组**lowbit()**函数。

方法：*x*=*x*&-*x*

###### 三、状压例题——关灯问题

题目描述：

现有n盏灯，以及m个按钮。每个按钮可以同时控制这n盏灯——按下了第i个按钮，对于所有的灯都有一个效果。按下i按钮对于第j盏灯，是下面3中效果之一：如果a[i][j]为1，那么当这盏灯开了的时候，把它关上，否则不管；如果为-1的话，如果这盏灯是关的，那么把它打开，否则也不管；如果是0，无论这灯是否开，都不管。

现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。

算法分析：

用二进制数表示当前n盏灯的状态，也相当于有向图中结点，每个状态和开关组成的元组对应一条边，终点可通过位运算算出。

类似BFS维护一个队列，对队首的某一状态，枚举每一个开关灯操作，记录到达这一新状态的步数（也就是老状态+1），若是最终答案，输出，若不是，压入队列。

总结：

本题特点在于**由老状态算新状态容易**，只需遍历开关，但想要**由新状态算老状态很难**，即地图不让玩家看到全貌，要一点点探索，**同时有m个侦察兵**，故而可以使用BFS的思想。

###### 四、状压DP例题——多米诺骨牌覆盖

**原始版**

题目描述：

2014.7.19，HWD老师提出一个令同学们抓头的问题：有一个m 行n 列的矩形方格棋盘，用1*2 的骨牌(可横放或竖放)完全覆盖，骨牌不能重叠，有多少种不同的覆盖的方法。
HWD老师不想看到长串的高精度数，你只需要求出覆盖方法总数 mod 10007 的值即可。

算法分析：

采用状态压缩动态规划，cnt\[i][j]表示第0至i-1行全填满，第i行为状态j的放置方法种数。假设第i行的骨牌全是竖着的，得到状态max-j，在其基础上放置横着的骨牌得到若干状态，即为i-1行的可到cnt\[i][j]的所有状态，加在一起，边加边模

总结：

本题特点在于**由老状态算新状态难**，但想要**由新状态算老状态比较容易**，而且**隔层没有关系**，用滚动数组可以节省空间，而且可以先做预处理，把状态转移关系先算出来（**这个关系每两行之间都一样**），节省时间。

感觉手有点生，还要多写程序。

