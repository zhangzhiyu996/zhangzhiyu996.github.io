# zhangzhiyu996.github.io

##### 2月10日

### 2020年大寒假程序训练笔记

##### 第一章 状压DP

###### 一、总述

**状压DP**是利用**计算机二进制**的性质来描述状态的一种DP方式，经常与BFS和DP联用，棋盘问题尤其多见

###### 二、常见位运算

1.判断一个数字x二进制下第i位是不是等于1。

方法：*if*(((1<<(*i*−1))&*x*)>0)

2.将一个数字x二进制下第i位更改成1。

方法：*x*=*x*\|(1<<(*i*−1))

3.把一个数字二进制下**最靠右的第一个1去掉**。

方法：*x*=*x*&(*x*−1)

4.最低位1的位置，树状数组**lowbit()**函数。

方法：*x*=*x*&-*x*

###### 三、状压例题——关灯问题

题目描述：

现有n盏灯，以及m个按钮。每个按钮可以同时控制这n盏灯——按下了第i个按钮，对于所有的灯都有一个效果。按下i按钮对于第j盏灯，是下面3中效果之一：如果a[i][j]为1，那么当这盏灯开了的时候，把它关上，否则不管；如果为-1的话，如果这盏灯是关的，那么把它打开，否则也不管；如果是0，无论这灯是否开，都不管。

现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。

算法分析：

用二进制数表示当前n盏灯的状态，也相当于有向图中结点，每个状态和开关组成的元组对应一条边，终点可通过位运算算出。

类似BFS维护一个队列，对队首的某一状态，枚举每一个开关灯操作，记录到达这一新状态的步数（也就是老状态+1），若是最终答案，输出，若不是，压入队列。

总结：

本题特点在于**由老状态算新状态容易**，只需遍历开关，但想要**由新状态算老状态很难**，即地图不让玩家看到全貌，要一点点探索，**同时有m个侦察兵**，故而可以使用BFS的思想。

###### 四、状压DP例题——多米诺骨牌覆盖

**原始版**

题目描述：

2014.7.19，HWD老师提出一个令同学们抓头的问题：有一个m 行n 列的矩形方格棋盘，用1*2 的骨牌(可横放或竖放)完全覆盖，骨牌不能重叠，有多少种不同的覆盖的方法。
HWD老师不想看到长串的高精度数，你只需要求出覆盖方法总数 mod 10007 的值即可。

数据规模：

0<n<=10 , 0<m<=100

算法分析：

采用状态压缩动态规划，cnt\[i][j]表示第0至i-1行全填满，第i行为状态j的放置方法种数。假设第i行的骨牌全是竖着的，得到状态max-j，在其基础上放置横着的骨牌得到若干状态，即为i-1行的可到cnt\[i][j]的所有状态，加在一起，边加边模

总结与反思：

本题特点在于**由老状态算新状态难**，但想要**由新状态算老状态比较容易**，而且**隔层没有关系**，用滚动数组可以节省空间，而且可以先做预处理，把状态转移关系先算出来（**这个关系每两行之间都一样**），节省时间。

感觉手有点生，还要多写程序。

##### 2月11日

**加强版1**

题目描述：

棋盘中有一些p个位置有破洞，坐标分别为（xi（第xi列），yi（第yi行））,这些位置不能放置骨牌了。

数据规模：

0<n<=10 , 0<m<=100 ，0<=p<=m*n

算法分析：

仍旧采用状压DP，注意计算cnt\[i][j]时得到上一行状态max-j还须补上当前行的破洞，最后得到若干可能的老状态还须判断其所在（即上一行）破洞是否填上。

总结与反思：

本题和原版思想一样，但行与行之间的状态转移随行变化而变化，以至于无法一次性预处理，每行都需枚举状态，计算其可能的老状态。需注意的是从上一行转移到本行，可填入跨两行的竖着的骨牌，也可填入置于本行的横着的骨牌，计算方法是假设本行的所有都由竖着的骨牌填入，然后尝试填入可能的横着的骨牌，从一边开始进行递归可得。处理破洞也可用位运算，破洞位置1，其它置0，得到一个map数组，填进破洞就是“或”上map相应行，判断破洞是否填入就是“与”上map相应行再比较是不是还与map相应行相等。

**加强版2**

题目描述：

与原版一致，数据规模有变化

数据规模：

0<n<=5 , 0<m<=1,000,000,000 （十亿）

算法分析：

思路上先把原版想明白，发现在行数变得很大时可采用**矩阵快速幂**优化。因为每两行之间状态转移是一样的，用线性代数的方法表示就是一个$$2^n\times2^n$$的矩阵的m次方再乘n维向量$$[0 0 0 0 ... 0 1]^{T}$$。

总结与反思：

有效使用数学表示对算法进行优化是程序设计的必经之路。计算机(Computer)，机算(compute)，永远少不了数学。

今天重新写了一遍原版的程序的基础上，做了两道加强版，对状态压缩动态规划有了更深的了解。

##### 2月12日、2月13日

###### 五、状压DP例题2——瓷砖铺放

题目描述：

给了一nxm的方格，用1x3的瓷砖铺满，请问有多少种铺法。瓷砖可以旋转，输出对65521取余的结果。

数据规模：

对于30%的数据，1<=n<=10, 1<=m<=3。
对于50%的数据，1<=n<=30，1<=m<=6。
对于100%的数据，1<=n<=100，1<=m<=7。

算法分析：

思路上和多米诺骨牌放置一样，区别在于这次的状态需要考虑最上面的两行，下面全铺满的情况，每一层允许放竖着的或者在最上面的一行的横着的瓷砖，也就相当于计算可能的老状态时在基础老状态上填2x3的矩形得到。

总结与反思：

在实现的过程中，犯了三个错。

一是把多米诺那题迁移过来时，有一个**边界条件忘了改**。

二是疏忽了**位运算优先级没有逻辑运算优先级高**。

三是初始化的时候要判断可能的老状态下层是满的而且**上层要是放了若干横着的瓷砖**的情形。

针对第三个问题，我试验了如果在底下加一层就不用考虑复杂的初始情形，只需老状态有两层都完全填充即为1。

其它都和多米诺骨牌放置一样。

